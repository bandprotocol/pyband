# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: bandchain/v1/oracle/proof.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....oracle import v1 as ___oracle_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class QueryProofRequest(betterproto.Message):
    """QueryProofRequest is request type for the Service/Proof RPC method."""

    request_id: int = betterproto.uint64_field(1)
    """RequestID is ID of an oracle request"""

    height: int = betterproto.int64_field(2)
    """height is block height"""


@dataclass(eq=False, repr=False)
class QueryProofResponse(betterproto.Message):
    """
    QueryChainIDResponse is response type for the Service/Proof RPC method.
    """

    height: int = betterproto.int64_field(1)
    """height is block height"""

    result: "SingleProofResponse" = betterproto.message_field(2)
    """result is the proof"""


@dataclass(eq=False, repr=False)
class QueryMultiProofRequest(betterproto.Message):
    """
    QueryMultiProofRequest is request type for the Service/MultiProof RPC
    method.
    """

    request_ids: List[int] = betterproto.uint64_field(1)
    """request_ids is the list of request IDs"""


@dataclass(eq=False, repr=False)
class QueryMultiProofResponse(betterproto.Message):
    """
    QueryMultiProofResponse is response type for the Service/MultiProof RPC
    method.
    """

    height: int = betterproto.int64_field(1)
    result: "MultiProofResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryRequestCountProofRequest(betterproto.Message):
    """
    QueryRequestCountProofRequest is request type for the
    Service/RequestCountProof RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class QueryRequestCountProofResponse(betterproto.Message):
    """
    QueryRequestCountProofResponse is response type for the
    Service/RequestCountProof RPC method.
    """

    height: int = betterproto.int64_field(1)
    result: "CountProofResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class SingleProofResponse(betterproto.Message):
    """
    SingleProofResponse is the data structure for response of single proof
    """

    proof: "SingleProof" = betterproto.message_field(1)
    evm_proof_bytes: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class MultiProofResponse(betterproto.Message):
    """MultiProofResponse is the data structure for response of multi proof"""

    proof: "MultiProof" = betterproto.message_field(1)
    evm_proof_bytes: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class CountProofResponse(betterproto.Message):
    """CountProofResponse is the data structure for response of count proof"""

    proof: "CountProof" = betterproto.message_field(1)
    evm_proof_bytes: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class SingleProof(betterproto.Message):
    """
    SingleProof contains block height, oracle data proof and block relay proof
    """

    block_height: int = betterproto.uint64_field(1)
    oracle_data_proof: "OracleDataProof" = betterproto.message_field(2)
    block_relay_proof: "BlockRelayProof" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MultiProof(betterproto.Message):
    """
    MultiProof contains block height, list of oracle data proof and block relay
    proof
    """

    block_height: int = betterproto.uint64_field(1)
    oracle_data_multi_proof: List["OracleDataProof"] = betterproto.message_field(2)
    block_relay_proof: "BlockRelayProof" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class CountProof(betterproto.Message):
    """CountProof contains block height, count proof and block relay proof"""

    block_height: int = betterproto.uint64_field(1)
    count_proof: "RequestsCountProof" = betterproto.message_field(2)
    block_relay_proof: "BlockRelayProof" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class OracleDataProof(betterproto.Message):
    """OracleDataProof contains result, version and merkle paths"""

    result: "___oracle_v1__.Result" = betterproto.message_field(1)
    version: int = betterproto.uint64_field(2)
    merkle_paths: List["IavlMerklePath"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class IavlMerklePath(betterproto.Message):
    """
    IAVLMerklePath represents a Merkle step to a leaf data node in an iAVL
    tree.
    """

    is_data_on_right: bool = betterproto.bool_field(1)
    subtree_height: int = betterproto.uint32_field(2)
    subtree_size: int = betterproto.uint64_field(3)
    subtree_version: int = betterproto.uint64_field(4)
    sibling_hash: bytes = betterproto.bytes_field(5)


@dataclass(eq=False, repr=False)
class BlockRelayProof(betterproto.Message):
    """
    BlockRelayProof contains multi store proof, block header merkle parts,
    common encoded part and signatures
    """

    multi_store_proof: "MultiStoreProof" = betterproto.message_field(1)
    block_header_merkle_parts: "BlockHeaderMerkleParts" = betterproto.message_field(2)
    common_encoded_vote_part: "CommonEncodedVotePart" = betterproto.message_field(3)
    signatures: List["TmSignature"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class MultiStoreProof(betterproto.Message):
    """
    MultiStoreProof stores a compact of other Cosmos-SDK modules' storage hash
    in multistore to compute (in combination with oracle store hash)
    Tendermint's application state hash at a given block.
    ___________________[AppHash]_________________
    /                                             \
    ___________[N19]____________                           ____[N20]______
    /                            \                         /               \
    ____[N15]____                 ____[N16]______              _[N17]__
    _[N18]_             /             \               /               \
    /       \       /       \        __[N8]_        __[N9]_         _[N10]_
    _[N11]_       [N12]   [N13]   [N14]    [M]      /       \       /      \
    /       \        /      \      /   \   /   \   /  \    [N0]    [N1]    [N2]
    [N3]   [N4]     [N5]    [N6]    [N7]   [G] [H] [I] [J] [K] [L]         /
    \   /   \    /  \   /   \   /   \   /   \   /   \   /   \  [0] [1] [2] [3]
    [4] [5] [6] [7] [8] [9] [A] [B] [C] [D] [E] [F] [0] - acc (auth) [1] -
    authz    [2] - bank     [3] - capability [4] - consensus  [5] - crisis [6]
    - dist       [7] - evidence [8] - feegrant [9] - globalfee  [A] - gov
    [B] - group [C] - ibccore    [D] - icahost  [E] - mint     [F] - oracle
    [G] - params     [H] - rollingseed [I] - slashing   [J] - staking  [K] -
    transfer [L] - tss        [M] - upgrade Notice that NOT all leaves of the
    Merkle tree are needed in order to compute the Merkle root hash, since we
    only want to validate the correctness of [F] In fact, only [E], [N6],
    [N10], [N15], and [N20] are needed in order to compute [AppHash].
    """

    oracle_iavl_state_hash: bytes = betterproto.bytes_field(1)
    mint_store_merkle_hash: bytes = betterproto.bytes_field(2)
    ibc_to_icahost_stores_merkle_hash: bytes = betterproto.bytes_field(3)
    feegrant_to_group_stores_merkle_hash: bytes = betterproto.bytes_field(4)
    auth_to_evidence_stores_merkle_hash: bytes = betterproto.bytes_field(5)
    params_to_upgrade_stores_merkle_hash: bytes = betterproto.bytes_field(6)


@dataclass(eq=False, repr=False)
class BlockHeaderMerkleParts(betterproto.Message):
    """
    BlockHeaderMerkleParts stores a group of hashes using for computing
    Tendermint's block header hash from app hash, and height. In Tendermint, a
    block header hash is the Merkle hash of a binary tree with 14 leaf nodes.
    Each node encodes a data piece of the blockchain. The notable data leaves
    are: [A] app_hash, [2] height. All data pieces are combined into one
    32-byte hash to be signed by block validators. The structure of the Merkle
    tree is shown below.                                  [BlockHeader]
    /                \                         [3A]
    [3B]                  /      \                                /      \
    [2A]                [2B]                [2C]                [2D]       /
    \              /    \              /    \              /    \          [1A]
    [1B]      [1C]      [1D]      [1E]      [1F]        [C]    [D]        /  \
    /  \      /  \      /  \      /  \      /  \        [0]  [1]  [2]  [3]  [4]
    [5]  [6]  [7]  [8]  [9]  [A]  [B]      [0] - version               [1] -
    chain_id            [2] - height        [3] - time    [4] - last_block_id
    [5] - last_commit_hash    [6] - data_hash     [7] - validators_hash [8] -
    next_validators_hash  [9] - consensus_hash      [A] - app_hash      [B] -
    last_results_hash       [C] - evidence_hash         [D] - proposer_address
    Notice that NOT all leaves of the Merkle tree are needed in order to
    compute the Merkle root hash, since we only want to validate the
    correctness of [2], [3], and [A]. In fact, only [1A], [2B], [1E], [B], and
    [2D] are needed in order to compute [BlockHeader].
    """

    version_and_chain_id_hash: bytes = betterproto.bytes_field(1)
    height: int = betterproto.uint64_field(2)
    time_second: int = betterproto.uint64_field(3)
    time_nano_second: int = betterproto.uint32_field(4)
    last_block_id_and_other: bytes = betterproto.bytes_field(5)
    next_validator_hash_and_consensus_hash: bytes = betterproto.bytes_field(6)
    last_results_hash: bytes = betterproto.bytes_field(7)
    evidence_and_proposer_hash: bytes = betterproto.bytes_field(8)


@dataclass(eq=False, repr=False)
class CommonEncodedVotePart(betterproto.Message):
    """CommonEncodedVotePart represents the common part of encoded vote"""

    signed_data_prefix: bytes = betterproto.bytes_field(1)
    signed_data_suffix: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class TmSignature(betterproto.Message):
    """
    TMSignature contains all details of validator signature for performing
    signer recovery for ECDSA secp256k1 signature. Note that this struct is
    written specifically for signature signed on Tendermint's precommit data,
    which includes the block hash and some additional information prepended and
    appended to the block hash. The prepended part (prefix) and the appended
    part (suffix) are different for each signer (including signature size,
    machine clock, validator index, etc).
    """

    r: bytes = betterproto.bytes_field(1)
    s: bytes = betterproto.bytes_field(2)
    v: int = betterproto.uint32_field(3)
    encoded_timestamp: bytes = betterproto.bytes_field(4)


@dataclass(eq=False, repr=False)
class RequestsCountProof(betterproto.Message):
    """RequestsCountProof contains count, version and merkle paths"""

    count: int = betterproto.uint64_field(1)
    version: int = betterproto.uint64_field(2)
    merkle_paths: List["IavlMerklePath"] = betterproto.message_field(3)


class ServiceStub(betterproto.ServiceStub):
    async def proof(
        self,
        query_proof_request: "QueryProofRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryProofResponse":
        return await self._unary_unary(
            "/bandchain.v1.oracle.Service/Proof",
            query_proof_request,
            QueryProofResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def multi_proof(
        self,
        query_multi_proof_request: "QueryMultiProofRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryMultiProofResponse":
        return await self._unary_unary(
            "/bandchain.v1.oracle.Service/MultiProof",
            query_multi_proof_request,
            QueryMultiProofResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def request_count_proof(
        self,
        query_request_count_proof_request: "QueryRequestCountProofRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryRequestCountProofResponse":
        return await self._unary_unary(
            "/bandchain.v1.oracle.Service/RequestCountProof",
            query_request_count_proof_request,
            QueryRequestCountProofResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ServiceBase(ServiceBase):
    async def proof(
        self, query_proof_request: "QueryProofRequest"
    ) -> "QueryProofResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def multi_proof(
        self, query_multi_proof_request: "QueryMultiProofRequest"
    ) -> "QueryMultiProofResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def request_count_proof(
        self, query_request_count_proof_request: "QueryRequestCountProofRequest"
    ) -> "QueryRequestCountProofResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_proof(
        self, stream: "grpclib.server.Stream[QueryProofRequest, QueryProofResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.proof(request)
        await stream.send_message(response)

    async def __rpc_multi_proof(
        self,
        stream: "grpclib.server.Stream[QueryMultiProofRequest, QueryMultiProofResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.multi_proof(request)
        await stream.send_message(response)

    async def __rpc_request_count_proof(
        self,
        stream: "grpclib.server.Stream[QueryRequestCountProofRequest, QueryRequestCountProofResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.request_count_proof(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/bandchain.v1.oracle.Service/Proof": grpclib.const.Handler(
                self.__rpc_proof,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryProofRequest,
                QueryProofResponse,
            ),
            "/bandchain.v1.oracle.Service/MultiProof": grpclib.const.Handler(
                self.__rpc_multi_proof,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryMultiProofRequest,
                QueryMultiProofResponse,
            ),
            "/bandchain.v1.oracle.Service/RequestCountProof": grpclib.const.Handler(
                self.__rpc_request_count_proof,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryRequestCountProofRequest,
                QueryRequestCountProofResponse,
            ),
        }

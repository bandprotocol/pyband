# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: band/tunnel/v1beta1/genesis.proto, band/tunnel/v1beta1/params.proto, band/tunnel/v1beta1/query.proto, band/tunnel/v1beta1/route.proto, band/tunnel/v1beta1/tunnel.proto, band/tunnel/v1beta1/tx.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....cosmos.base import v1beta1 as __cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as __cosmos_base_query_v1_beta1__
from ...feeds import v1beta1 as __feeds_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class TunnelStatusFilter(betterproto.Enum):
    """TunnelStatusFilter defines a filter for tunnel status."""

    UNSPECIFIED = 0
    """TUNNEL_STATUS_FILTER_UNSPECIFIED defines an unspecified status."""

    ACTIVE = 1
    """TUNNEL_STATUS_FILTER_ACTIVE defines an active tunnel."""

    INACTIVE = 2
    """TUNNEL_STATUS_FILTER_INACTIVE defines an inactive tunnel."""


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """
    Params is the data structure that keeps the parameters of the module.
    """

    min_deposit: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)
    """min_deposit is the minimum deposit required to create a tunnel."""

    min_interval: int = betterproto.uint64_field(2)
    """min_interval is the minimum interval in seconds."""

    max_interval: int = betterproto.uint64_field(3)
    """max_interval is the maximum interval in seconds."""

    min_deviation_bps: int = betterproto.uint64_field(4)
    """min_deviation_bps is the minimum deviation in basis points."""

    max_deviation_bps: int = betterproto.uint64_field(5)
    """max_deviation_bps is the maximum deviation in basis points."""

    max_signals: int = betterproto.uint64_field(6)
    """
    max_signals defines the maximum number of signals allowed per tunnel.
    """

    base_packet_fee: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(7)
    """base_packet_fee is the base fee for each packet."""


@dataclass(eq=False, repr=False)
class Tunnel(betterproto.Message):
    """
    Tunnel contains the information of the tunnel that is created by the user
    """

    id: int = betterproto.uint64_field(1)
    """id is the tunnel ID"""

    sequence: int = betterproto.uint64_field(2)
    """sequence is representing the sequence of the tunnel packet."""

    route: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(3)
    """route is the route for delivering the signal prices"""

    fee_payer: str = betterproto.string_field(4)
    """fee_payer is the address of the fee payer"""

    signal_deviations: List["SignalDeviation"] = betterproto.message_field(5)
    """signal_deviations is the list of signal deviations"""

    interval: int = betterproto.uint64_field(6)
    """interval is the interval for delivering the signal prices"""

    total_deposit: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(7)
    """total_deposit is the total deposit on the tunnel."""

    is_active: bool = betterproto.bool_field(8)
    """is_active is the flag to indicate if the tunnel is active"""

    created_at: int = betterproto.int64_field(9)
    """created_at is the timestamp when the tunnel is created"""

    creator: str = betterproto.string_field(10)
    """creator is the address of the creator"""


@dataclass(eq=False, repr=False)
class LatestPrices(betterproto.Message):
    """LatestPrices is the type for prices that tunnel produces"""

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the tunnel ID"""

    prices: List["__feeds_v1_beta1__.Price"] = betterproto.message_field(2)
    """prices is the list of prices information from feeds module."""

    last_interval: int = betterproto.int64_field(3)
    """
    last_interval is the last interval when the signal prices are produced by interval trigger
    """


@dataclass(eq=False, repr=False)
class TotalFees(betterproto.Message):
    """TotalFees is the type for the total fees collected by the tunnel"""

    total_base_packet_fee: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)
    """
    total_base_packet_fee is the total base packet fee collected by the tunnel
    """


@dataclass(eq=False, repr=False)
class Packet(betterproto.Message):
    """Packet is the packet that tunnel produces"""

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the tunnel ID"""

    sequence: int = betterproto.uint64_field(2)
    """sequence is representing the sequence of the tunnel packet."""

    prices: List["__feeds_v1_beta1__.Price"] = betterproto.message_field(3)
    """prices is the list of prices information from feeds module."""

    receipt: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(4)
    """
    receipt represents the confirmation of the packet delivery to the destination via the specified route.
    """

    created_at: int = betterproto.int64_field(5)
    """created_at is the timestamp when the packet is created"""


@dataclass(eq=False, repr=False)
class Deposit(betterproto.Message):
    """
    Deposit defines an amount deposited by an account address to the tunnel.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id defines the unique id of the tunnel."""

    depositor: str = betterproto.string_field(2)
    """depositor defines the deposit addresses from the proposals."""

    amount: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)
    """amount to be deposited by depositor."""


@dataclass(eq=False, repr=False)
class SignalDeviation(betterproto.Message):
    """
    SignalDeviation is the type for a signal with soft and hard deviation
    """

    signal_id: str = betterproto.string_field(1)
    """signal_id is the signal ID"""

    soft_deviation_bps: int = betterproto.uint64_field(2)
    """soft_deviation_bps is the soft deviation in basis points"""

    hard_deviation_bps: int = betterproto.uint64_field(3)
    """hard_deviation_bps is the hard deviation in basis points"""


@dataclass(eq=False, repr=False)
class TunnelSignatureOrder(betterproto.Message):
    """
    TunnelSignatureOrder defines a general signature order for sending signature to tss group.
    """

    sequence: int = betterproto.uint64_field(1)
    """sequence is the sequence of the packet"""

    prices: List["__feeds_v1_beta1__.Price"] = betterproto.message_field(2)
    """prices is the list of prices information from feeds module."""

    created_at: int = betterproto.int64_field(3)
    """created_at is the timestamp when the packet is created"""

    encoder: "__feeds_v1_beta1__.Encoder" = betterproto.enum_field(4)
    """encoder is the mode of encoding data."""


@dataclass(eq=False, repr=False)
class MsgCreateTunnel(betterproto.Message):
    """MsgCreateTunnel is the transaction message to create a new tunnel."""

    signal_deviations: List["SignalDeviation"] = betterproto.message_field(1)
    """signal_deviations is the list of signal deviations."""

    interval: int = betterproto.uint64_field(2)
    """
    interval is the interval for delivering the signal prices in seconds.
    """

    route: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(3)
    """route is the route for delivering the signal prices"""

    initial_deposit: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)
    """
    initial_deposit is the deposit value that must be paid at tunnel creation.
    """

    creator: str = betterproto.string_field(5)
    """creator is the address of the creator."""


@dataclass(eq=False, repr=False)
class MsgCreateTunnelResponse(betterproto.Message):
    """
    MsgCreateTunnelResponse is the response type for the Msg/CreateTunnel RPC method.
    """

    tunnel_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class MsgUpdateRoute(betterproto.Message):
    """
    MsgUpdateRoute is the transaction message to update a route information of the tunnel.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to edit."""

    route: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    """route is the route for delivering the signal prices"""

    creator: str = betterproto.string_field(3)
    """creator is the address of the creator."""


@dataclass(eq=False, repr=False)
class MsgUpdateRouteResponse(betterproto.Message):
    """
    MsgUpdateRouteResponse is the response type for the Msg/UpdateRoute RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateSignalsAndInterval(betterproto.Message):
    """
    MsgUpdateSignalsAndInterval is the transaction message to update signals and interval of the tunnel.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to edit."""

    signal_deviations: List["SignalDeviation"] = betterproto.message_field(2)
    """signal_deviations is the list of signal deviations."""

    interval: int = betterproto.uint64_field(3)
    """interval is the interval for delivering the signal prices."""

    creator: str = betterproto.string_field(4)
    """creator is the address of the creator."""


@dataclass(eq=False, repr=False)
class MsgUpdateSignalsAndIntervalResponse(betterproto.Message):
    """
    MsgUpdateSignalsAndIntervalResponse is the response type for the Msg/UpdateSignalsAndInterval RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgWithdrawFeePayerFunds(betterproto.Message):
    """
    MsgWithdrawFeePayerFunds is the transaction message to withdraw fee payer funds to creator.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to withdraw fee payer coins."""

    amount: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)
    """amount is the coins to withdraw."""

    creator: str = betterproto.string_field(3)
    """creator is the address of the creator."""


@dataclass(eq=False, repr=False)
class MsgWithdrawFeePayerFundsResponse(betterproto.Message):
    """
    MsgWithdrawFeePayerFundsResponse is the response type for the Msg/WithdrawFeePayerFunds RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgActivateTunnel(betterproto.Message):
    """MsgActivateTunnel is the transaction message to activate a tunnel."""

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to activate."""

    creator: str = betterproto.string_field(2)
    """creator is the address of the creator."""


@dataclass(eq=False, repr=False)
class MsgActivateTunnelResponse(betterproto.Message):
    """
    MsgActivateTunnelResponse is the response type for the Msg/Activate RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgDeactivateTunnel(betterproto.Message):
    """
    MsgDeactivateTunnel is the transaction message to deactivate a tunnel.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to deactivate."""

    creator: str = betterproto.string_field(2)
    """creator is the address of the creator."""


@dataclass(eq=False, repr=False)
class MsgDeactivateTunnelResponse(betterproto.Message):
    """
    MsgDeactivateTunnelResponse is the response type for the Msg/Deactivate RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgTriggerTunnel(betterproto.Message):
    """
    MsgTriggerTunnel is the transaction message to manually trigger a tunnel.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to manually trigger."""

    creator: str = betterproto.string_field(2)
    """creator is the address of the creator."""


@dataclass(eq=False, repr=False)
class MsgTriggerTunnelResponse(betterproto.Message):
    """
    MsgTriggerTunnelResponse is the response type for the Msg/TriggerTunnel RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgDepositToTunnel(betterproto.Message):
    """
    MsgDepositToTunnel defines a message to deposit to an existing tunnel.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id defines the unique id of the tunnel."""

    amount: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)
    """amount to be deposited by depositor."""

    depositor: str = betterproto.string_field(3)
    """depositor defines the deposit addresses from the tunnel."""


@dataclass(eq=False, repr=False)
class MsgDepositToTunnelResponse(betterproto.Message):
    """
    MsgDepositToTunnelResponse defines the Msg/DepositToTunnel response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgWithdrawFromTunnel(betterproto.Message):
    """
    MsgWithdrawFromTunnel is the transaction message to withdraw a deposit from an existing tunnel.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id defines the unique id of the tunnel."""

    amount: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)
    """amount to be withdrawn by withdrawer."""

    withdrawer: str = betterproto.string_field(3)
    """withdrawer defines the withdraw addresses from the tunnel."""


@dataclass(eq=False, repr=False)
class MsgWithdrawFromTunnelResponse(betterproto.Message):
    """
    MsgWithdrawFromTunnelResponse defines the Msg/WithdrawFromTunnel response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateParams(betterproto.Message):
    """MsgUpdateParams is the transaction message to update parameters."""

    authority: str = betterproto.string_field(1)
    """authority is the address of the governance account."""

    params: "Params" = betterproto.message_field(2)
    """params is the x/tunnel parameters to update."""


@dataclass(eq=False, repr=False)
class MsgUpdateParamsResponse(betterproto.Message):
    """
    MsgUpdateParamsResponse is the response type for the Msg/UpdateParams RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class TssRoute(betterproto.Message):
    """
    TSSRoute represents a route for TSS packets and implements the RouteI interface.
    """

    destination_chain_id: str = betterproto.string_field(1)
    """destination_chain_id is the destination chain ID"""

    destination_contract_address: str = betterproto.string_field(2)
    """destination_contract_address is the destination contract address"""

    encoder: "__feeds_v1_beta1__.Encoder" = betterproto.enum_field(3)
    """encoder is the mode of encoding packet data."""


@dataclass(eq=False, repr=False)
class TssPacketReceipt(betterproto.Message):
    """
    TSSPacketReceipt represents a receipt for a TSS packet and implements the PacketReceiptI interface.
    """

    signing_id: int = betterproto.uint64_field(1)
    """signing_id is the signing ID"""


@dataclass(eq=False, repr=False)
class IbcRoute(betterproto.Message):
    """
    IBCRoute represents a route for IBC packets and implements the RouteI interface.
    """

    channel_id: str = betterproto.string_field(1)
    """channel_id is the IBC channel ID"""


@dataclass(eq=False, repr=False)
class IbcPacketReceipt(betterproto.Message):
    """
    IBCPacketReceipt represents a receipt for a IBC packet and implements the PacketReceiptI interface.
    """

    sequence: int = betterproto.uint64_field(1)
    """sequence is representing the sequence of the IBC packet."""


@dataclass(eq=False, repr=False)
class TunnelPricesPacketData(betterproto.Message):
    """
    TunnelPricesPacketData represents the IBC packet payload for the tunnel packet.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the tunnel ID"""

    sequence: int = betterproto.uint64_field(2)
    """sequence is representing the sequence of the tunnel packet."""

    prices: List["__feeds_v1_beta1__.Price"] = betterproto.message_field(3)
    """prices is the list of prices information from feeds module."""

    created_at: int = betterproto.int64_field(4)
    """created_at is the timestamp when the packet is created"""


@dataclass(eq=False, repr=False)
class QueryTunnelsRequest(betterproto.Message):
    """
    QueryTunnelsRequest is the request type for the Query/Tunnels RPC method.
    """

    status_filter: "TunnelStatusFilter" = betterproto.enum_field(1)
    """status_filter is a flag to filter tunnels by status."""

    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryTunnelsResponse(betterproto.Message):
    """
    QueryTunnelsResponse is the response type for the Query/Tunnels RPC method.
    """

    tunnels: List["Tunnel"] = betterproto.message_field(1)
    """Tunnels is a list of tunnels."""

    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines an optional pagination for the response."""


@dataclass(eq=False, repr=False)
class QueryTunnelRequest(betterproto.Message):
    """
    QueryTunnelRequest is the request type for the Query/Tunnel RPC method.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to query."""


@dataclass(eq=False, repr=False)
class QueryTunnelResponse(betterproto.Message):
    """
    QueryTunnelResponse is the response type for the Query/Tunnel RPC method.
    """

    tunnel: "Tunnel" = betterproto.message_field(1)
    """tunnel is the tunnel with the given ID."""


@dataclass(eq=False, repr=False)
class QueryDepositsRequest(betterproto.Message):
    """
    QueryDepositsRequest is the request type for the Query/Deposits RPC method.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to query deposits."""

    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryDepositsResponse(betterproto.Message):
    """
    QueryDepositsResponse is the response type for the Query/Deposits RPC method.
    """

    deposits: List["Deposit"] = betterproto.message_field(1)
    """deposits is a list of deposits."""

    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines an optional pagination for the response."""


@dataclass(eq=False, repr=False)
class QueryDepositRequest(betterproto.Message):
    """
    QueryDepositRequest is the request type for the Query/Deposit RPC method.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to query."""

    depositor: str = betterproto.string_field(2)
    """depositor is the address of the depositor to query."""


@dataclass(eq=False, repr=False)
class QueryDepositResponse(betterproto.Message):
    """
    QueryDepositResponse is the response type for the Query/Deposit RPC method.
    """

    deposit: "Deposit" = betterproto.message_field(1)
    """
    deposit is the deposit with the given tunnel ID and depositor address.
    """


@dataclass(eq=False, repr=False)
class QueryPacketsRequest(betterproto.Message):
    """
    QueryPacketsRequest is the request type for the Query/Packets RPC method.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to query packets."""

    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryPacketsResponse(betterproto.Message):
    """
    QueryPacketsResponse is the response type for the Query/Packets RPC method.
    """

    packets: List["Packet"] = betterproto.message_field(1)
    """packets is a list of packets."""

    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines an optional pagination for the response."""


@dataclass(eq=False, repr=False)
class QueryPacketRequest(betterproto.Message):
    """
    QueryPacketRequest is the request type for the Query/Packet RPC method.
    """

    tunnel_id: int = betterproto.uint64_field(1)
    """tunnel_id is the ID of the tunnel to query packets."""

    sequence: int = betterproto.uint64_field(2)
    """sequence is the sequence of the packet to query."""


@dataclass(eq=False, repr=False)
class QueryPacketResponse(betterproto.Message):
    """
    QueryPacketResponse is the response type for the Query/Packet RPC method.
    """

    packet: "Packet" = betterproto.message_field(1)
    """packet is the packet with the given tunnel ID and sequence."""


@dataclass(eq=False, repr=False)
class QueryTotalFeesRequest(betterproto.Message):
    """
    QueryTotalFeesRequest is the request type for the Query/TotalFees RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class QueryTotalFeesResponse(betterproto.Message):
    """
    QueryTotalFeesResponse is the response type for the Query/TotalFees RPC method.
    """

    total_fees: "TotalFees" = betterproto.message_field(1)
    """total_fees is the total fees collected by the tunnel."""


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """
    QueryParamsRequest is the request type for the Query/Params RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is the response type for the Query/Params RPC method.
    """

    params: "Params" = betterproto.message_field(1)
    """params is the parameters of the module."""


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState represents the initial state of the blockchain."""

    params: "Params" = betterproto.message_field(1)
    """params is all parameters of the module."""

    tunnel_count: int = betterproto.uint64_field(2)
    """tunnel_count is the number of tunnels."""

    tunnels: List["Tunnel"] = betterproto.message_field(3)
    """tunnels is the list of tunnels."""

    deposits: List["Deposit"] = betterproto.message_field(4)
    """deposits is the list of deposits."""

    total_fees: "TotalFees" = betterproto.message_field(5)
    """total_fees is the type for the total fees collected by the tunnel"""


class MsgStub(betterproto.ServiceStub):
    async def create_tunnel(
        self,
        msg_create_tunnel: "MsgCreateTunnel",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCreateTunnelResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/CreateTunnel",
            msg_create_tunnel,
            MsgCreateTunnelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_route(
        self,
        msg_update_route: "MsgUpdateRoute",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateRouteResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/UpdateRoute",
            msg_update_route,
            MsgUpdateRouteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_signals_and_interval(
        self,
        msg_update_signals_and_interval: "MsgUpdateSignalsAndInterval",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateSignalsAndIntervalResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/UpdateSignalsAndInterval",
            msg_update_signals_and_interval,
            MsgUpdateSignalsAndIntervalResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def withdraw_fee_payer_funds(
        self,
        msg_withdraw_fee_payer_funds: "MsgWithdrawFeePayerFunds",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgWithdrawFeePayerFundsResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/WithdrawFeePayerFunds",
            msg_withdraw_fee_payer_funds,
            MsgWithdrawFeePayerFundsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def activate_tunnel(
        self,
        msg_activate_tunnel: "MsgActivateTunnel",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgActivateTunnelResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/ActivateTunnel",
            msg_activate_tunnel,
            MsgActivateTunnelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def deactivate_tunnel(
        self,
        msg_deactivate_tunnel: "MsgDeactivateTunnel",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgDeactivateTunnelResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/DeactivateTunnel",
            msg_deactivate_tunnel,
            MsgDeactivateTunnelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def trigger_tunnel(
        self,
        msg_trigger_tunnel: "MsgTriggerTunnel",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgTriggerTunnelResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/TriggerTunnel",
            msg_trigger_tunnel,
            MsgTriggerTunnelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def deposit_to_tunnel(
        self,
        msg_deposit_to_tunnel: "MsgDepositToTunnel",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgDepositToTunnelResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/DepositToTunnel",
            msg_deposit_to_tunnel,
            MsgDepositToTunnelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def withdraw_from_tunnel(
        self,
        msg_withdraw_from_tunnel: "MsgWithdrawFromTunnel",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgWithdrawFromTunnelResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/WithdrawFromTunnel",
            msg_withdraw_from_tunnel,
            MsgWithdrawFromTunnelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_params(
        self,
        msg_update_params: "MsgUpdateParams",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateParamsResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Msg/UpdateParams",
            msg_update_params,
            MsgUpdateParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def tunnels(
        self,
        query_tunnels_request: "QueryTunnelsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryTunnelsResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Query/Tunnels",
            query_tunnels_request,
            QueryTunnelsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def tunnel(
        self,
        query_tunnel_request: "QueryTunnelRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryTunnelResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Query/Tunnel",
            query_tunnel_request,
            QueryTunnelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def deposits(
        self,
        query_deposits_request: "QueryDepositsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryDepositsResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Query/Deposits",
            query_deposits_request,
            QueryDepositsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def deposit(
        self,
        query_deposit_request: "QueryDepositRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryDepositResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Query/Deposit",
            query_deposit_request,
            QueryDepositResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def packets(
        self,
        query_packets_request: "QueryPacketsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPacketsResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Query/Packets",
            query_packets_request,
            QueryPacketsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def packet(
        self,
        query_packet_request: "QueryPacketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPacketResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Query/Packet",
            query_packet_request,
            QueryPacketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def total_fees(
        self,
        query_total_fees_request: "QueryTotalFeesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryTotalFeesResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Query/TotalFees",
            query_total_fees_request,
            QueryTotalFeesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/band.tunnel.v1beta1.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):
    async def create_tunnel(self, msg_create_tunnel: "MsgCreateTunnel") -> "MsgCreateTunnelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_route(self, msg_update_route: "MsgUpdateRoute") -> "MsgUpdateRouteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_signals_and_interval(
        self, msg_update_signals_and_interval: "MsgUpdateSignalsAndInterval"
    ) -> "MsgUpdateSignalsAndIntervalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def withdraw_fee_payer_funds(
        self, msg_withdraw_fee_payer_funds: "MsgWithdrawFeePayerFunds"
    ) -> "MsgWithdrawFeePayerFundsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def activate_tunnel(self, msg_activate_tunnel: "MsgActivateTunnel") -> "MsgActivateTunnelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def deactivate_tunnel(self, msg_deactivate_tunnel: "MsgDeactivateTunnel") -> "MsgDeactivateTunnelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def trigger_tunnel(self, msg_trigger_tunnel: "MsgTriggerTunnel") -> "MsgTriggerTunnelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def deposit_to_tunnel(self, msg_deposit_to_tunnel: "MsgDepositToTunnel") -> "MsgDepositToTunnelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def withdraw_from_tunnel(
        self, msg_withdraw_from_tunnel: "MsgWithdrawFromTunnel"
    ) -> "MsgWithdrawFromTunnelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_params(self, msg_update_params: "MsgUpdateParams") -> "MsgUpdateParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_tunnel(
        self, stream: "grpclib.server.Stream[MsgCreateTunnel, MsgCreateTunnelResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_tunnel(request)
        await stream.send_message(response)

    async def __rpc_update_route(
        self, stream: "grpclib.server.Stream[MsgUpdateRoute, MsgUpdateRouteResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_route(request)
        await stream.send_message(response)

    async def __rpc_update_signals_and_interval(
        self,
        stream: "grpclib.server.Stream[MsgUpdateSignalsAndInterval, MsgUpdateSignalsAndIntervalResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_signals_and_interval(request)
        await stream.send_message(response)

    async def __rpc_withdraw_fee_payer_funds(
        self,
        stream: "grpclib.server.Stream[MsgWithdrawFeePayerFunds, MsgWithdrawFeePayerFundsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.withdraw_fee_payer_funds(request)
        await stream.send_message(response)

    async def __rpc_activate_tunnel(
        self,
        stream: "grpclib.server.Stream[MsgActivateTunnel, MsgActivateTunnelResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.activate_tunnel(request)
        await stream.send_message(response)

    async def __rpc_deactivate_tunnel(
        self,
        stream: "grpclib.server.Stream[MsgDeactivateTunnel, MsgDeactivateTunnelResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.deactivate_tunnel(request)
        await stream.send_message(response)

    async def __rpc_trigger_tunnel(
        self,
        stream: "grpclib.server.Stream[MsgTriggerTunnel, MsgTriggerTunnelResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.trigger_tunnel(request)
        await stream.send_message(response)

    async def __rpc_deposit_to_tunnel(
        self,
        stream: "grpclib.server.Stream[MsgDepositToTunnel, MsgDepositToTunnelResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.deposit_to_tunnel(request)
        await stream.send_message(response)

    async def __rpc_withdraw_from_tunnel(
        self,
        stream: "grpclib.server.Stream[MsgWithdrawFromTunnel, MsgWithdrawFromTunnelResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.withdraw_from_tunnel(request)
        await stream.send_message(response)

    async def __rpc_update_params(
        self, stream: "grpclib.server.Stream[MsgUpdateParams, MsgUpdateParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/band.tunnel.v1beta1.Msg/CreateTunnel": grpclib.const.Handler(
                self.__rpc_create_tunnel,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateTunnel,
                MsgCreateTunnelResponse,
            ),
            "/band.tunnel.v1beta1.Msg/UpdateRoute": grpclib.const.Handler(
                self.__rpc_update_route,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateRoute,
                MsgUpdateRouteResponse,
            ),
            "/band.tunnel.v1beta1.Msg/UpdateSignalsAndInterval": grpclib.const.Handler(
                self.__rpc_update_signals_and_interval,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateSignalsAndInterval,
                MsgUpdateSignalsAndIntervalResponse,
            ),
            "/band.tunnel.v1beta1.Msg/WithdrawFeePayerFunds": grpclib.const.Handler(
                self.__rpc_withdraw_fee_payer_funds,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgWithdrawFeePayerFunds,
                MsgWithdrawFeePayerFundsResponse,
            ),
            "/band.tunnel.v1beta1.Msg/ActivateTunnel": grpclib.const.Handler(
                self.__rpc_activate_tunnel,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgActivateTunnel,
                MsgActivateTunnelResponse,
            ),
            "/band.tunnel.v1beta1.Msg/DeactivateTunnel": grpclib.const.Handler(
                self.__rpc_deactivate_tunnel,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDeactivateTunnel,
                MsgDeactivateTunnelResponse,
            ),
            "/band.tunnel.v1beta1.Msg/TriggerTunnel": grpclib.const.Handler(
                self.__rpc_trigger_tunnel,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgTriggerTunnel,
                MsgTriggerTunnelResponse,
            ),
            "/band.tunnel.v1beta1.Msg/DepositToTunnel": grpclib.const.Handler(
                self.__rpc_deposit_to_tunnel,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDepositToTunnel,
                MsgDepositToTunnelResponse,
            ),
            "/band.tunnel.v1beta1.Msg/WithdrawFromTunnel": grpclib.const.Handler(
                self.__rpc_withdraw_from_tunnel,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgWithdrawFromTunnel,
                MsgWithdrawFromTunnelResponse,
            ),
            "/band.tunnel.v1beta1.Msg/UpdateParams": grpclib.const.Handler(
                self.__rpc_update_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateParams,
                MsgUpdateParamsResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def tunnels(self, query_tunnels_request: "QueryTunnelsRequest") -> "QueryTunnelsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def tunnel(self, query_tunnel_request: "QueryTunnelRequest") -> "QueryTunnelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def deposits(self, query_deposits_request: "QueryDepositsRequest") -> "QueryDepositsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def deposit(self, query_deposit_request: "QueryDepositRequest") -> "QueryDepositResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def packets(self, query_packets_request: "QueryPacketsRequest") -> "QueryPacketsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def packet(self, query_packet_request: "QueryPacketRequest") -> "QueryPacketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def total_fees(self, query_total_fees_request: "QueryTotalFeesRequest") -> "QueryTotalFeesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def params(self, query_params_request: "QueryParamsRequest") -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_tunnels(self, stream: "grpclib.server.Stream[QueryTunnelsRequest, QueryTunnelsResponse]") -> None:
        request = await stream.recv_message()
        response = await self.tunnels(request)
        await stream.send_message(response)

    async def __rpc_tunnel(self, stream: "grpclib.server.Stream[QueryTunnelRequest, QueryTunnelResponse]") -> None:
        request = await stream.recv_message()
        response = await self.tunnel(request)
        await stream.send_message(response)

    async def __rpc_deposits(
        self,
        stream: "grpclib.server.Stream[QueryDepositsRequest, QueryDepositsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.deposits(request)
        await stream.send_message(response)

    async def __rpc_deposit(self, stream: "grpclib.server.Stream[QueryDepositRequest, QueryDepositResponse]") -> None:
        request = await stream.recv_message()
        response = await self.deposit(request)
        await stream.send_message(response)

    async def __rpc_packets(self, stream: "grpclib.server.Stream[QueryPacketsRequest, QueryPacketsResponse]") -> None:
        request = await stream.recv_message()
        response = await self.packets(request)
        await stream.send_message(response)

    async def __rpc_packet(self, stream: "grpclib.server.Stream[QueryPacketRequest, QueryPacketResponse]") -> None:
        request = await stream.recv_message()
        response = await self.packet(request)
        await stream.send_message(response)

    async def __rpc_total_fees(
        self,
        stream: "grpclib.server.Stream[QueryTotalFeesRequest, QueryTotalFeesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.total_fees(request)
        await stream.send_message(response)

    async def __rpc_params(self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]") -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/band.tunnel.v1beta1.Query/Tunnels": grpclib.const.Handler(
                self.__rpc_tunnels,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTunnelsRequest,
                QueryTunnelsResponse,
            ),
            "/band.tunnel.v1beta1.Query/Tunnel": grpclib.const.Handler(
                self.__rpc_tunnel,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTunnelRequest,
                QueryTunnelResponse,
            ),
            "/band.tunnel.v1beta1.Query/Deposits": grpclib.const.Handler(
                self.__rpc_deposits,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryDepositsRequest,
                QueryDepositsResponse,
            ),
            "/band.tunnel.v1beta1.Query/Deposit": grpclib.const.Handler(
                self.__rpc_deposit,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryDepositRequest,
                QueryDepositResponse,
            ),
            "/band.tunnel.v1beta1.Query/Packets": grpclib.const.Handler(
                self.__rpc_packets,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPacketsRequest,
                QueryPacketsResponse,
            ),
            "/band.tunnel.v1beta1.Query/Packet": grpclib.const.Handler(
                self.__rpc_packet,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPacketRequest,
                QueryPacketResponse,
            ),
            "/band.tunnel.v1beta1.Query/TotalFees": grpclib.const.Handler(
                self.__rpc_total_fees,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTotalFeesRequest,
                QueryTotalFeesResponse,
            ),
            "/band.tunnel.v1beta1.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
        }

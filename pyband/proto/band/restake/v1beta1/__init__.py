# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: band/restake/v1beta1/genesis.proto, band/restake/v1beta1/query.proto, band/restake/v1beta1/tx.proto, band/restake/v1beta1/types.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....cosmos.base import v1beta1 as __cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as __cosmos_base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class Vault(betterproto.Message):
    """Vault is used for tracking the status of the vaults."""

    key: str = betterproto.string_field(1)
    """key is the key of the vault."""

    is_active: bool = betterproto.bool_field(2)
    """is_active is the status of the vault"""


@dataclass(eq=False, repr=False)
class Lock(betterproto.Message):
    """Lock is used to store lock information of each user on each vault."""

    staker_address: str = betterproto.string_field(1)
    """staker_address is the owner's address of the staker."""

    key: str = betterproto.string_field(2)
    """key is the key of the vault that this lock is locked to."""

    power: str = betterproto.string_field(3)
    """power is the number of locked power."""


@dataclass(eq=False, repr=False)
class Stake(betterproto.Message):
    """Stake is used to store staked coins of an address."""

    staker_address: str = betterproto.string_field(1)
    """staker_address is the address that this stake belongs to."""

    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)
    """coins are the coins that the address has staked."""


@dataclass(eq=False, repr=False)
class LockResponse(betterproto.Message):
    """
    LockResponse is used as response of the query to show the power
     that is locked by the vault for the user.
    """

    key: str = betterproto.string_field(1)
    """key is the key of the vault that this lock belongs to."""

    power: str = betterproto.string_field(2)
    """power is the number of locked power."""


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState represents the initial state of the blockchain."""

    params: "Params" = betterproto.message_field(1)
    """params is all parameters of the module."""

    vaults: List["Vault"] = betterproto.message_field(2)
    """vaults is a list of vaults in the module."""

    locks: List["Lock"] = betterproto.message_field(3)
    """locks is a list of locks in the module."""

    stakes: List["Stake"] = betterproto.message_field(4)
    """stakes is a list of stakes in the module."""


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params is the data structure that keeps the parameters."""

    allowed_denoms: List[str] = betterproto.string_field(1)
    """
    allowed_denoms is a list of denoms that the module allows to stake to get power.
    """


@dataclass(eq=False, repr=False)
class MsgStake(betterproto.Message):
    """MsgStake is the request message type for staking coins."""

    staker_address: str = betterproto.string_field(1)
    """staker_address is the address that will stake the coins."""

    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)
    """coins is the coins that will be staked."""


@dataclass(eq=False, repr=False)
class MsgStakeResponse(betterproto.Message):
    """MsgStakeResponse is the response message type for staking coins."""

    pass


@dataclass(eq=False, repr=False)
class MsgUnstake(betterproto.Message):
    """MsgUnstake is the request message type for unstaking coins."""

    staker_address: str = betterproto.string_field(1)
    """staker_address is the address that will unstake the coins."""

    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)
    """coins is the coins that will be unstaked."""


@dataclass(eq=False, repr=False)
class MsgUnstakeResponse(betterproto.Message):
    """MsgUnstakeResponse is the response message type for unstaking coins."""

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateParams(betterproto.Message):
    """MsgUpdateParams is the transaction message to update parameters."""

    authority: str = betterproto.string_field(1)
    """authority is the address of the governance account."""

    params: "Params" = betterproto.message_field(2)
    """params is parameters to update."""


@dataclass(eq=False, repr=False)
class MsgUpdateParamsResponse(betterproto.Message):
    """
    MsgUpdateParamsResponse is the response type for the Msg/UpdateParams RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class QueryVaultsRequest(betterproto.Message):
    """
    QueryVaultsRequest represents the request type for the Query/Vaults RPC method.
    """

    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )
    """pagination defines optional pagination parameters."""


@dataclass(eq=False, repr=False)
class QueryVaultsResponse(betterproto.Message):
    """
    QueryVaultsResponse represents the response type for the Query/Vaults RPC method.
    """

    vaults: List["Vault"] = betterproto.message_field(1)
    """vaults is a list of vaults."""

    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )
    """pagination defines pagination parameters in the response."""


@dataclass(eq=False, repr=False)
class QueryVaultRequest(betterproto.Message):
    """
    QueryVaultRequest represents the request type for the Query/Vault RPC method.
    """

    key: str = betterproto.string_field(1)
    """key is the key of the vault that want to query."""


@dataclass(eq=False, repr=False)
class QueryVaultResponse(betterproto.Message):
    """
    QueryVaultResponse represents the response type for the Query/Vault RPC method.
    """

    vault: "Vault" = betterproto.message_field(1)
    """vault is a vault information."""


@dataclass(eq=False, repr=False)
class QueryLocksRequest(betterproto.Message):
    """
    QueryLocksRequest represents the request type for the Query/Locks RPC method.
    """

    staker_address: str = betterproto.string_field(1)
    """staker_address is the target address to query locks."""

    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(2)
    )
    """pagination defines optional pagination parameters."""


@dataclass(eq=False, repr=False)
class QueryLocksResponse(betterproto.Message):
    """
    QueryLocksResponse represents the response type for the Query/Locks RPC method.
    """

    locks: List["LockResponse"] = betterproto.message_field(1)
    """locks is a list of locks of the staker."""

    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )
    """pagination defines pagination parameters in the response."""


@dataclass(eq=False, repr=False)
class QueryLockRequest(betterproto.Message):
    """
    QueryLockRequest represents the request type for the Query/Lock RPC method.
    """

    staker_address: str = betterproto.string_field(1)
    """staker_address is the target address to query lock."""

    key: str = betterproto.string_field(2)
    """key is the key of target vault to query lock."""


@dataclass(eq=False, repr=False)
class QueryLockResponse(betterproto.Message):
    """
    QueryLockResponse represents the response type for the Query/Lock RPC method.
    """

    lock: "LockResponse" = betterproto.message_field(1)
    """lock is the lock of the staker and the vault."""


@dataclass(eq=False, repr=False)
class QueryStakeRequest(betterproto.Message):
    """
    QueryStakeRequest represents the request type for the Query/Stake RPC method.
    """

    staker_address: str = betterproto.string_field(1)
    """staker_address is the target address used to query the stake."""


@dataclass(eq=False, repr=False)
class QueryStakeResponse(betterproto.Message):
    """
    QueryStakeResponse represents the response type for the Query/Stake RPC method.
    """

    stake: "Stake" = betterproto.message_field(1)
    """stake is a stake information of the staker."""


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """
    QueryParamsRequest is the request type for the Query/Params RPC method.
    """

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is the response type for the Query/Params RPC method.
    """

    params: "Params" = betterproto.message_field(1)
    """params are the parameters of the module."""


class MsgStub(betterproto.ServiceStub):
    async def stake(
        self,
        msg_stake: "MsgStake",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgStakeResponse":
        return await self._unary_unary(
            "/band.restake.v1beta1.Msg/Stake",
            msg_stake,
            MsgStakeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def unstake(
        self,
        msg_unstake: "MsgUnstake",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUnstakeResponse":
        return await self._unary_unary(
            "/band.restake.v1beta1.Msg/Unstake",
            msg_unstake,
            MsgUnstakeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_params(
        self,
        msg_update_params: "MsgUpdateParams",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateParamsResponse":
        return await self._unary_unary(
            "/band.restake.v1beta1.Msg/UpdateParams",
            msg_update_params,
            MsgUpdateParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def vaults(
        self,
        query_vaults_request: "QueryVaultsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryVaultsResponse":
        return await self._unary_unary(
            "/band.restake.v1beta1.Query/Vaults",
            query_vaults_request,
            QueryVaultsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def vault(
        self,
        query_vault_request: "QueryVaultRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryVaultResponse":
        return await self._unary_unary(
            "/band.restake.v1beta1.Query/Vault",
            query_vault_request,
            QueryVaultResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def locks(
        self,
        query_locks_request: "QueryLocksRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryLocksResponse":
        return await self._unary_unary(
            "/band.restake.v1beta1.Query/Locks",
            query_locks_request,
            QueryLocksResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def lock(
        self,
        query_lock_request: "QueryLockRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryLockResponse":
        return await self._unary_unary(
            "/band.restake.v1beta1.Query/Lock",
            query_lock_request,
            QueryLockResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stake(
        self,
        query_stake_request: "QueryStakeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryStakeResponse":
        return await self._unary_unary(
            "/band.restake.v1beta1.Query/Stake",
            query_stake_request,
            QueryStakeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/band.restake.v1beta1.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):

    async def stake(self, msg_stake: "MsgStake") -> "MsgStakeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def unstake(self, msg_unstake: "MsgUnstake") -> "MsgUnstakeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_params(
        self, msg_update_params: "MsgUpdateParams"
    ) -> "MsgUpdateParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stake(
        self, stream: "grpclib.server.Stream[MsgStake, MsgStakeResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.stake(request)
        await stream.send_message(response)

    async def __rpc_unstake(
        self, stream: "grpclib.server.Stream[MsgUnstake, MsgUnstakeResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.unstake(request)
        await stream.send_message(response)

    async def __rpc_update_params(
        self, stream: "grpclib.server.Stream[MsgUpdateParams, MsgUpdateParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/band.restake.v1beta1.Msg/Stake": grpclib.const.Handler(
                self.__rpc_stake,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgStake,
                MsgStakeResponse,
            ),
            "/band.restake.v1beta1.Msg/Unstake": grpclib.const.Handler(
                self.__rpc_unstake,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUnstake,
                MsgUnstakeResponse,
            ),
            "/band.restake.v1beta1.Msg/UpdateParams": grpclib.const.Handler(
                self.__rpc_update_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateParams,
                MsgUpdateParamsResponse,
            ),
        }


class QueryBase(ServiceBase):

    async def vaults(
        self, query_vaults_request: "QueryVaultsRequest"
    ) -> "QueryVaultsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def vault(
        self, query_vault_request: "QueryVaultRequest"
    ) -> "QueryVaultResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def locks(
        self, query_locks_request: "QueryLocksRequest"
    ) -> "QueryLocksResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def lock(self, query_lock_request: "QueryLockRequest") -> "QueryLockResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stake(
        self, query_stake_request: "QueryStakeRequest"
    ) -> "QueryStakeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def params(
        self, query_params_request: "QueryParamsRequest"
    ) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_vaults(
        self, stream: "grpclib.server.Stream[QueryVaultsRequest, QueryVaultsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.vaults(request)
        await stream.send_message(response)

    async def __rpc_vault(
        self, stream: "grpclib.server.Stream[QueryVaultRequest, QueryVaultResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.vault(request)
        await stream.send_message(response)

    async def __rpc_locks(
        self, stream: "grpclib.server.Stream[QueryLocksRequest, QueryLocksResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.locks(request)
        await stream.send_message(response)

    async def __rpc_lock(
        self, stream: "grpclib.server.Stream[QueryLockRequest, QueryLockResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.lock(request)
        await stream.send_message(response)

    async def __rpc_stake(
        self, stream: "grpclib.server.Stream[QueryStakeRequest, QueryStakeResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.stake(request)
        await stream.send_message(response)

    async def __rpc_params(
        self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/band.restake.v1beta1.Query/Vaults": grpclib.const.Handler(
                self.__rpc_vaults,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVaultsRequest,
                QueryVaultsResponse,
            ),
            "/band.restake.v1beta1.Query/Vault": grpclib.const.Handler(
                self.__rpc_vault,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVaultRequest,
                QueryVaultResponse,
            ),
            "/band.restake.v1beta1.Query/Locks": grpclib.const.Handler(
                self.__rpc_locks,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLocksRequest,
                QueryLocksResponse,
            ),
            "/band.restake.v1beta1.Query/Lock": grpclib.const.Handler(
                self.__rpc_lock,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLockRequest,
                QueryLockResponse,
            ),
            "/band.restake.v1beta1.Query/Stake": grpclib.const.Handler(
                self.__rpc_stake,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryStakeRequest,
                QueryStakeResponse,
            ),
            "/band.restake.v1beta1.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
        }
